/*

Batch No- 30

2011A7PS108P - Rishab Kalra

2011A7PS087P- Ishan Bansal

*/


/*

a) FIRST and FOLLOW Automated

b) Both lexical and syntax analysis modules developed

c) Modules work with testcases 1,2,3,4 uploaded on your webpage and testcases 5,6,7 which are our own genertaed test cases.
	 
d) Parse Tree Constructed

*/



/*
	printing Parse tree.
	
	If node is nonTerminal then lineNo is default -1
	lexemeCurrent Node is ---
	token is empty
	valueIfNumber is -1
	
	
	If node is terminal then and it is not a number then default value is -1 
*/


#include<stdio.h>
#include<string.h>
#include "parser.h"
#include "hash2.h"
#include "stackDef.h"
#include "lexer.h"
#include "lexerDef.h"
#include "ast.h"
#include "AST_DEF.h"
#include "symbolTable.h"
#include "typeChecker.h"

int main(int argc, char* argv[])
{

	printf("\n\n LEVEL 3: Symbol Table/AST/Semantic Rules/Type checking modules work\n\n");
		
	hashTable2 h;
	int numNonTerminals;  int numTerminals;
	createEmptyHashTable(h);
	FILE *fp = fopen ("grammar.txt", "r");
	Grammar g = readGrammarAndMakeHashTable(fp, h, &numNonTerminals, &numTerminals);
	fclose(fp);
	
	
	int table[100][100];
	
	createParseTable(h, g, table, numTerminals, numNonTerminals);
	
	printf("Press option for the desired task\n");
	printf("1. for  printing the token list generated by the lexer (on the console)\n\n");
	printf("2. for parsing to verify the syntactic correctness of the input source code  and to produce parse tree\n\n");
	printf("3. for printing the Abstract Syntax Tree in depth first order in appropriate format\n\n");
	printf("4. for  printing the Symbol Table \n\n");
	printf("5. for compiling (front end only) to verify the syntactic and semantic correctness of the input source code and to produce errors as per the ERROR list, if the type mismatch occurs or the code is semantically not correct.\n\n");
	printf("6. for producing assembly code .\n\n\n");       

       

       
	
	int state;
	scanf("%d",&state);
	tree_LINK root;
	ast_LINK ast_root;
	symbolTable st;
	scopeStack s;
	int isOutput;
	int curOffset=0;
	type ty=DEFAULT;
	switch(state)
	{
		case 1:
		parseInputSourceCode(argv[1],table,h,g,1);
		break;
		
		case 2:
		parseInputSourceCode(argv[1],table,h,g,2);
		break;
		case 3:
		root=parseInputSourceCode(argv[1],table,h,g,2);
		ast_root=generateAST(root);
		printAST(ast_root);
		//fp=fopen(argv[2],"w");
		//printParseTree(root,fp,"ROOT");
		break;
		case 4:
		//printHashTable(h);
		root=parseInputSourceCode(argv[1],table,h,g,2);
		ast_root=generateAST(root);
		st=initSymTable();
		s=initStack();
		strcpy(st.ptr[0].scopeName,"_main");
		s=pushScope(s,0);
		st.numScopes=1;
		//symbolTable fillTable(ast_LINK root, symbolTable st,type curType,scopeStack s,int isOutput)
		st=fillTable(ast_root,st,ty,s,isOutput,&curOffset,ast_root,0,NULL,4);
		//printf("!!!!!!!!!!symbol table!!!!!!!!!!!\n");
		
		printSymbolTable(st);
		//printAST(ast_root);
		
		//printf("!!!!!!!!!!!!!!!!!!!typeChecking!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
		//typeChecker(ast_root);
		break;		
		
		
		case 5:
		
		root=parseInputSourceCode(argv[1],table,h,g,2);
		ast_root=generateAST(root);
		st=initSymTable();
		s=initStack();
		strcpy(st.ptr[0].scopeName,"_main");
		s=pushScope(s,0);
		st.numScopes=1;
		//symbolTable fillTable(ast_LINK root, symbolTable st,type curType,scopeStack s,int isOutput)
		st=fillTable(ast_root,st,ty,s,isOutput,&curOffset,ast_root,0,NULL,5);
		typeChecker(ast_root);
		break;
				
		case 6:
		break;
		
	}
	
	return 0;
}
